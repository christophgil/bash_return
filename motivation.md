# Motivation

The *return* command in Bash is usually used to return *EXIT_SUCCESS* or an  error code from function.
It can only return integers between 0 and 255. It  is not applicable to pass strings or numeric values from the function to the caller.


Strings or numeric values are often  printed to standard output by function. The caller can easily capture the standard output. See
section *Returning Strings* in https://ioflood.com/blog/bash-function-return-value

    function square() {
        echo $(($1*$1))
    }
    result=$(square 3)
    echo "The square of 3 is $value"

This looks nice and  compact. However, it wastes about a millisecond which leads to long running loops.
A serious risk is that output generated by commands inside the function  get  also captured, when the programmer forgets a redirection to */dev/stderr*.
This may happen upon  code  refactoring.

Alternative strategies have been  discussed to improve performance based on variables without involving */dev/stdout*: https://stackoverflow.com/questions/3236871/how-to-return-a-string-value-from-a-bash-function

The following suggestion looks promising at first glance.

    function square() {
        declare -n RETURN_FROM_square=$1
        shift
        RETURN_FROM_square=$(($1*$1))
    }
    square  value 3
    echo "The square of 3 is $value"

The code correctly prints the square of the number 3.  However, if a line like

    local value=8

is added to the body of the function, the code is broken. This variable name is also used by
the caller.  This method fails to fully encapsulate the local variables. Furthermore the static code checkers report some false warnings.
They falsely assume that *value* is referenced, but never assigned.

Apparently, it is not easily possible to get a satisfactory solution at shell script level.

Therefore the extension  has been implemented as a bash-builtin in C.
